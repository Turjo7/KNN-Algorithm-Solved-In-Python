# -*- coding: utf-8 -*-
"""KNN Algorithm 2021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1reet8ZiXPEBf1YnTWYZg8U1_Xd2emb2i

Classification Problem
"""

#Dataset Uploading Iris Dataset
from google.colab import files
uploaded = files.upload()

#Directory Name Check
!ls

#Printing the  Iris Dataset
lines=[]

with open('iris.csv') as f:
    lines = f.read().splitlines()
    
print(lines[0:150])

#Spliting the Dataset Based on Comma in 2D List
wanted_lines = []
for i in range(0,len(lines)):
  line = lines[i].split(",")
  wanted_lines.append(line)
  
print(wanted_lines[0:150])

#Unique values from the last column of the dataset
outputs = []
for i in range(0,len(wanted_lines)):
  outputs.append(wanted_lines[i][-1])
output_set = set(outputs)
print(output_set)

#Dictionary Mapping of Data
output_dict={}
i=0
for element in output_set:
  print(element)
  output_dict[element] = i
  i=i+1
print(output_dict)

for i in range(0,len(wanted_lines)):
  wanted_lines[i][-1] = output_dict[wanted_lines[i][-1]]
print(wanted_lines)

#Turning into Numpy Array
import numpy as np

for i in range(0,len(wanted_lines)):
  for j in range(0,len(wanted_lines[0])):
    wanted_lines[i][j] = float(wanted_lines[i][j])

print(np.array(wanted_lines))

# Train, Test, Validation Spliting of the Dataset
import random

Train = []
Test = []
Validation = []

for i in range(0, len(wanted_lines)):
  R = random.uniform(0, 1)
  if(R>=0 and R<= 0.7):
    Train.append(wanted_lines[i])
  elif(R>0.7 and R<=0.85):
    Validation.append(wanted_lines[i])
  else:
    Test.append(wanted_lines[i])

print(len(Train))
print(len(Test))
print(len(Validation))

#Converting the Train , Test, Validation list to numpy array
train = np.array(Train)
validation = np.array(Validation)
test = np.array(Test)

print("Train Set\n",train,"\n")
print("Validation Set\n",validation,"\n")
print("Test Set\n",test,"\n")

import math
from collections import Counter



actual=0
sum=0.0
 
#K=1
#K=3
#K=5
#K=10
#K=15
K=20





for i in validation:
  distance_class=[]
  for j in train:
    distance=math.sqrt(pow(i[0]-j[0],2)+pow(i[1]-j[1],2)+pow(i[2]-j[2],2)+pow(i[3]-j[3],2))
    distance_class.append([distance,j[4]])
  distance_class=sorted(distance_class)
  
  nearest_k_neighbour=[]
  for x in range(K):
    nearest_k_neighbour.append(distance_class[x])
  nearest_k_neighbour=np.array(nearest_k_neighbour)
  max=Counter(nearest_k_neighbour.flat).most_common(1)
  
  print("Max Value",max[0][0])
  print("-------------------",max)
  
  
  
  
  
  
  
  
  if max[0][0] == i[4] :
    actual=actual+1
    
    
    
   
      
      
      
      
      
      
      
      
    
    print("Class:",max[0][0])
    #break
validation_accuracy=(actual/len(validation))*100




print("Accuracy For Classification : ",validation_accuracy)

import math
from collections import Counter



actual=0
sum=0.0
 
#K=1
#K=3
#K=5
#K=10
#K=15
K=20




for i in test:
  distance_class=[]
  for j in train:
    distance=math.sqrt(pow(i[0]-j[0],2)+pow(i[1]-j[1],2)+pow(i[2]-j[2],2)+pow(i[3]-j[3],2))
    distance_class.append([distance,j[4]])
  distance_class=sorted(distance_class)
  
  nearest_k_neighbour=[]
  for x in range(K):
    nearest_k_neighbour.append(distance_class[x])
  nearest_k_neighbour=np.array(nearest_k_neighbour)
  max=Counter(nearest_k_neighbour.flat).most_common(1)
  
  print("Max Value",max[0][0])
  print("-------------------",max)
  
  
  
  
  
  
  
  
  if max[0][0] == i[4] :
    actual=actual+1
    
    
    
   
      
      
      
      
      
      
      
      
    
    print("Class:",max[0][0])
    #break
validation_accuracy=(actual/len(validation))*100




print("Accuracy For Classification : ",validation_accuracy)

"""Regression

"""

#Dataset Uploading Diabetes.csv Dataset
from google.colab import files
uploaded = files.upload()

!ls

#Printing the  Diabetes Dataset
lines=[]

with open('diabetes.csv') as f:
    lines = f.read().splitlines()
    
print(lines[0:])

#Spliting the Dataset Based on Comma in 2D List
wanted_lines = []
for i in range(0,len(lines)):
  line = lines[i].split(",")
  wanted_lines.append(line)
  
print(wanted_lines[0:])

#Turning into Numpy Array
import numpy as np

for i in range(0,len(wanted_lines)):
  for j in range(0,len(wanted_lines[0])):
    wanted_lines[i][j] = float(wanted_lines[i][j])

print(np.array(wanted_lines))

# Train, Test, Validation Spliting of the Dataset
import random

Train = []
Test = []
Validation = []

for i in range(0, len(wanted_lines)):
  R = random.uniform(0, 1)
  if(R>=0 and R<= 0.7):
    Train.append(wanted_lines[i])
  elif(R>0.7 and R<=0.85):
    Validation.append(wanted_lines[i])
  else:
    Test.append(wanted_lines[i])

print(len(Train))
print(len(Test))
print(len(Validation))

#Converting the Train , Test, Validation list to numpy array
train = np.array(Train)
validation = np.array(Validation)
test = np.array(Test)

from scipy.spatial import distance
import operator
#k = 1
#k = 3
#k = 5
#k = 10
#k = 15
k = 20

L = {}
correct = 0
error = 0
for s in Validation:
  major_class = {}
  L = {}
  for v in Train:
    ed = distance.euclidean(s[0:(len(s)-1)], v[0:(len(v)-1)])
    L[ed] = v[-1]
  sorted_L = sorted(L.keys())

  
  count = 1
  total_val = 0.0
  for x in sorted_L:
    total_val = total_val + L[x]
    count = count + 1
    if(count > k):
      break
  val = total_val/k
  
  error = error + (s[-1] - val)**2
 
  if(int(s[-1]) == val):
    correct = correct + 1

error_r = (error/len(Validation))**(1/2)
print(error_r)

#Mean_Squared_Error for Test set

from scipy.spatial import distance
import operator
k = 20

L = {}
correct = 0
error = 0
for s in Test:
  major_class = {}
  L = {}
  for v in Train:
    ed = distance.euclidean(s[0:(len(s)-1)], v[0:(len(v)-1)])
    L[ed] = v[-1]
  sorted_L = sorted(L.keys())

  
  count = 1
  total_val = 0.0
  for x in sorted_L:
    total_val = total_val + L[x]
    count = count + 1
    if(count > k):
      break
  val = total_val/k
  
  error = error + (s[-1] - val)**2
 
  if(int(s[-1]) == val):
    correct = correct + 1

error_r = (error/len(Validation))**(1/2)
print(error_r)